<template>
<div v-if="error" class="box error">
  <h2> {{ $t('error') }} </h2>
  <p>{{ $t('error-loading-image') }}</p>
</div>
<div v-else class="cytomine-viewer">
  <b-loading :is-full-page="false" :active="loading" />
  <div v-if="!loading" class="maps-wrapper">
    <div class="map-cell" v-for="idx in nbHorizontalCells*nbVerticalCells" :key="idx"
      :style="`height:${elementHeight}%; width:${elementWidth}%;`"
    >
      <cytomine-image
        v-if="idx <= nbMaps"
        :index="idx-1"
        :key="`${idx}-${viewer.maps[idx-1].imageInstance.id}`"
        @close="closeMap(idx-1)"
      />
    </div>

    <image-selector />

    <!-- Emit event when a hotkey is pressed (to rework once https://github.com/iFgR/vue-shortkey/issues/78 is implemented) -->
    <div class="hidden" v-shortkey.once="shortkeysMapping" @shortkey="shortkeyEvent"></div>
  </div>
</div>
</template>

<script>
import CytomineImage from './CytomineImage';
import ImageSelector from './ImageSelector';

import viewerModuleModel from '@/store/modules/project_modules/viewer';

import constants from '@/utils/constants.js';

import {ImageInstance} from 'cytomine-client';

export default {
  name: 'cytomine-viewer',
  components: {
    CytomineImage,
    ImageSelector
  },
  data() {
    return {
      error: false,
      loading: true,
      reloadInterval: null,
      idViewer: null
    };
  },
  computed: {
    project() {
      return this.$store.state.currentProject.project;
    },
    viewers() {
      return this.$store.state.projects[this.project.id].viewers;
    },
    idImages() {
      return this.$route.params.idImages.split('-');
    },
    paramIdViewer() {
      return this.$route.query.viewer;
    },
    viewerModule() {
      return this.$store.getters.currentViewerModule;
    },
    viewer() {
      return this.viewers[this.idViewer];
    },
    nbMaps() {
      return this.viewer ? this.viewer.maps.length : 0;
    },
    imageSelector() {
      return this.viewer ? this.viewer.imageSelector : false;
    },
    nbHorizontalCells() {
      return Math.ceil(Math.sqrt(this.nbMaps));
    },
    nbVerticalCells() {
      return this.nbHorizontalCells ? Math.ceil(this.nbMaps/this.nbHorizontalCells) : 0;
    },
    elementHeight() {
      return 100/this.nbVerticalCells;
    },
    elementWidth() {
      return 100/this.nbHorizontalCells;
    },
    shortkeysMapping() {
      // for shortkeys composed of a single key, return the key as srcKey
      let mapping = ['s', 'o', 'f', 'd', 'p', 'n'].reduce((object, key) => {
        object[key] = [key];
        return object;
      }, {});
      mapping.ctrlZ = ['ctrl', 'z']; // special handling because combination of keys should trigger the function
      mapping.ctrlY = ['ctrl', 'y']; // idem
      return mapping;
    }
  },
  watch: {
    paramIdViewer() {
      this.findIdViewer();
    },
    idViewer(_, old) {
      if(old) {
        this.loading = true;
        this.loadViewer();
      }
    },
    viewer() {
      if(!this.viewer) {
        console.log('Viewer closed from external source');
        this.$router.push(`/project/${this.$route.params.idProject}`);
      }
    },
    nbMaps() {
      this.$eventBus.$emit('updateMapSize');
    }
  },
  methods: {
    findIdViewer() {
      if(this.paramIdViewer) {
        this.idViewer = this.paramIdViewer;
        return;
      }

      for(let id in this.viewers) {
        // if viewer containing the targetted images, and only them, store its id
        if(this.viewers[id].maps.map(map => map.imageInstance.id).join('-') === this.$route.params.idImages) {
          this.idViewer = id;
          return;
        }
      }

      this.idViewer = '_' + Math.random().toString(36).substr(2, 9); // TODO: change the ways IDs are generated (discuss with team)
    },

    closeMap(index) {
      if(this.nbMaps === 1) {
        this.$store.unregisterModule(['projects', this.project.id, 'viewers', this.idViewer]);
        this.$router.push(`/project/${this.$route.params.idProject}`);
      }
      else {
        this.$store.dispatch(this.viewerModule + 'removeMap', index);
      }
    },

    async loadViewer() {
      try {
        this.$store.commit('setCurrentViewer', this.idViewer);
        if(!this.viewer) {
          this.$store.registerModule(['projects', this.project.id, 'viewers', this.idViewer], viewerModuleModel);
          this.$store.commit(this.viewerModule + 'setId', this.idViewer);
          await Promise.all(this.idImages.map(async id => {
            let image = await ImageInstance.fetch(id);
            await this.$store.dispatch(this.viewerModule + 'addMap', image);
          }));
        }
        else {
          await this.$store.dispatch(this.viewerModule + 'refreshData');
        }
        this.loading = false;
      }
      catch(err) {
        console.log(err);
        this.error = true;
      }
    },

    shortkeyEvent(event) {
      this.$eventBus.$emit('shortkeyEvent', event.srcKey);
    }
  },
  async created() {
    this.findIdViewer();
    await this.loadViewer();
    this.reloadInterval = setInterval(
      () => this.$eventBus.$emit('reloadAnnotations'),
      constants.VIEWER_ANNOTATIONS_REFRESH_INTERVAL
    );
  },
  beforeDestroy() {
    clearInterval(this.reloadInterval);
  }
};
</script>

<style scoped>
.cytomine-viewer {
  height: 100%;
}

.maps-wrapper {
  height: 100%;
  display: flex;
  flex-wrap: wrap;
  position: relative;
  overflow: hidden;
}

.map-cell {
  border-top: 0.2em solid #222;
  overflow: hidden;
}

.hidden {
  display: none;
}
</style>
